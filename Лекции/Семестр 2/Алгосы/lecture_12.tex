% !TEX root = ../../../main.tex

\begin{lemma}{про масштабирование}
  После выполнение $k$ итераций остается пустить не более $2^k E$ потока
  $$F \le F_k + 2^k E, \text{где $F_k$ - поток на $k$-ой итерации}$$
\end{lemma}

\begin{proof}
  $c_f \to \frac{c_f}{2^k} \then $ в остаточной сети с $capacity = \frac{c_f}{2^k}$ есть резрез веса 0. Масштабируем обратно. Поскольку при замене (масштабировании) мы округляем $capacity$ вниз, то рассматриваемый разрес будет иметь величину не больше $2^k E$, так как у каждого ребра остаток не превышает $2^k$.
\end{proof}

\subsection{Алгоритм Диница}
\textbf{Основаная идея:} Мы хотим насытить все кратчайшие пути на каждой итерации

\textit{В алгоритме ЭК насыщался один кратчайший путь, а сейчас мы хотим сделать несколько его итераций в одной}

\textbf{Асимптотика:} $O(V^2E)$

\begin{definition}
  Слоистая сеть по сети $G$ - граф, в котором вершины разбиты на множества $V_i = \{ v | dist(s,v) = i\}$, в которой ребра ведут из $V_i$ в $V_{i + 1}$ для какого-то $i$.
\end{definition}

\begin{note}
В слоистой сети не будет ребер внутри $V_i$ и между $V_j$ и $V_i$, если $j > i$
\end{note}

\begin{definition}
  Блокирующий поток - такой поток, который нельзя увеличить без введения обратных ребер.
\end{definition}

\textbf{Алгоритм:}
  Пока в $G_1$ есть путь из $s$ в $t$, по $G_f$ строим слоистую сеть и в ней ищем блокирующий поток.

  \begin{enumerate}
    \item Как строить слоистую сеть?

    Для этого будем запускать $BFS$ для ребер с положительной $capacity$.

    \item Как искать блокирующий поток?
    
    Объявим все ребра, заканчивающиеся в вершине $v$, из которой нельзя дойти до $t$, бесполезными. Их мы не будем использовать для увеличения потока.

    Пусть $ptr[v]$ - номер первого интересующего нас ребра, исходящего из вершины $v$


    \textbf{\textsc{Приведем реализацию функции на следующей странице:}}
  \newpage
  \begin{verbatim}
    int dfs(int v, int f) { \\ f - минимальное из capacity до пути к v
      if (v == t) return f;
  
      while(ptr[v] != g[v].size()) {
        пусть e - ptr[v]-ое ребро, исходящее из v

        if (e.capacity == e.flow || dist[e.to] != dist[v] + 1) {
          ++ptr[v]; continue; // ребро бесполнезное
        }

        x = dfs(e.to, std::min(f, e.flow - e.capacity));
  
        if (x == 0) {
          ++ptr[v]; continue; // ребро бесполнезное
        }

        e.flow += x; reversed_e.flow -= x; return x;
      }

      return 0;
    }
  \end{verbatim}
  \end{enumerate}

  \textbf{\textsc{Поиск блокирующего потока:}}

  \begin{verbatim}
    while(true) {
      x = dfs(s, \infty);

      if (x == 0) break;
    }
  \end{verbatim}

  \textit{Для оценки асимптотики достаточно понять следующее:}
  \begin{note}
    Если $k$ - количество увеличений $ptr$, то один запуск $dfs(s, \infty)$, будет работать за $O(V + k)$
  \end{note}

  \textbf{Итого:}
  $$\sum^E_{i = 1} (V + k_i) = VE + \underbrace{\sum k_i}_{\leq E} = O(VE)$$
  \begin{proposition}
    Пусть $G_f$ и $G_{f'}$ - остаточные сети после двух последовательных итераций алгоритма Диница. Тогда $dist'(s, t) > dist(s, t)$
  \end{proposition}
  \textit{Отсюда и следует искомая асимптотика}
  \begin{definition}
    \text{}

    \begin{enumerate}
      \item $c_{in}(v) = \sum_{u} c(u, v)$ - втекающая $capacity$
       \item $c_{out}(v) = \sum_{u} c(v, u)$ - вытекающая $capacity$
        \item $p(v) = min(c_{in}, c_{out}(v))$ - потенциал вершины $v$
        \item $P = \sum_{v \ne s, v \ne t} p(v)$ - потенциал сети.
    \end{enumerate}
  \end{definition}
  \begin{theorem}{1-ая теорема Карзанова}
    Количество итераций в алгоритме Диница есть $O(\sqrt{P})$
  \end{theorem}
  \begin{proof}
    \begin{lemma}
      Пусть $G$ - сеть, $l = dist(s, t)$, $F - max$ поток из $s$ в $t$, $P$ - потенциал сети. Тогда $l \le 1 + \frac{P}{F}$.
    \end{lemma}
    \begin{proof}
      Назовем потенциал в слое $V_i$: $P_i = \sum_{v \in V_i} p(v_i)$. Понятно, что $F \le P_i$.
      Складывая для каждого слоя нер-во, получаем $(l - 1) F \le \sum_{i = 1}^{l - 1} P_i \le P \then l - 1 \le \frac{P}{F}$
    \end{proof}

    \begin{lemma}
      При пропускания потока в сети ее потенциал не изменяется, то есть $P(G) = P(G_f)$
    \end{lemma}
    \begin{proof}
      Очев
    \end{proof}

    \textit{Теперь докажем теорему:}

    Выполним первые $sqrt{P}$ итераций в алгоритме Диница. Пусть $F$ - сколько потока осталось пустить. $l = dist(s, t)$ в текущей $G_f$. $P$ сейчас - такое же, как в начале. Так как $dist$ увеличивается хотя бы на 1, получаем с учетом леммы: $$\sqrt{P} \le l \le 1 + \frac{P}{F} \then \frac{P}{F} \ge \sqrt{P} - 1$$

    Таким образом, $F \le \frac{P}{\sqrt{P} - 1} = O(\sqrt{P})$, а тогда осталось не больше $O(\sqrt{P})$ итераций.
  \end{proof}


  \begin{proposition}{о декомпозиции потока}
    Любой поток можно представить в виде суммы единичных путей из $s$ в $t$ и единичных циклов.
  \end{proposition}

  \section{Единичные сети}

  Для таких сетей пропускная способность может равнять либо 0, либо 1. 

  \begin{enumerate}
    \item Алгоритм Диницы работает за $O(E \sqrt{E})$
    \begin{proof}
      Поскольку число итераций по теореме Карзанова равно $O(\sqrt{P}) = O(\sqrt{E})$, достаточно понять асимптотику работы одной итерации.

      Каждая итерация подразумевает $bfs$ и поиск блокирующего потока. Заметим, что каждое ребро рассматривается $\le 2$ раза, ведь все ребра на каждом пути сразу насыщаются и становятся бесполезными $\to O(E)$.
    \end{proof}

    \item В двудольном графе максимальное паросочетание может быть найдено за $O(E \sqrt{V})$.
    \begin{proof}
      Введем исток, соединенный с левой долей, и сток, соединенный с правой долей. Тогда максимальное паросочетание = максимальный поток в графе. Так как у вершин левой доли $c_{in} = 1$, а у правой - $c_{out} = 1 \then P = O(V)$.
    \end{proof}
  \end{enumerate}

  \textbf{Последний алгоритм называется алгоритмом Хопкрофта-Карпа}