% !TEX root = ../../../main.tex

\section{Динамическое программирование (окончание)}

\subsection{ДП с помощью масок}
Пусть \(U = \{0, 1, \dots, n-1\}\) $A \subset U$

Тогда будем записывать $A$ как массив длины $n$, где $i \in A \leftrightarrow a_i = 1$. Такое представление называется \textit{маской множества}

\textbf{Как проверить входит ли $x$ в $A$?}
\begin{center}
   bit(mask, pos) \{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

     \ \ return (mask >> pos) \& 1; \}
\end{center}

\textbf{Как брать пересечения и объединения?}

$$\begin{array}{|c|c|}
  \hline
  A \cap B & A \cup B \\
  \hline
   mask_{A} || mask_{B} &  mask_{A} \& mask_{B}\\
   \hline
\end{array}$$

\subsubsection{Задача 1} 

Пусть даны $a_{ij}$ - стоимость выполнения $j$-го задания $i$-ым работников.
Найти минимальную стоимость выполнения всех заданий.

\textsc{\textbf{Решение:}}

Пусть $dp[i][mask]$ - минимальная стоимость распределить первых $i$ работников, чтобы они выполнили множество заданий маски.

$$dp[i][mask] = min_{b \in mask}(a_{ib} + dp[i-1][\underbrace{mask | b}_{mask + (1 << b)}])$$

\textit{Асимптотика:} $O(2^n n^2)$

\subsubsection{Задача 2} Максимальная клика в графе за $O(2^{\frac{n}{2}})$

\begin{definition}
  Клика $C \subset V$ такова, что для любых ее двух вершин есть ребро между ними.
\end{definition}

Решим пока задачу за $O(2^k)$, где $k$ - количество вершин

Обозначим за $neighbour(v)$ маску соседей $v$

Тогда $clique(mask) = true \leftrightarrow clique(mask | v) = true, mask | v \subset neighbour(v)$

Осталось только придумать, как из маски за $O(1)$ выкидывать ее вершину.

Сделаем это предпосчетом для каждой маски за $O(2^k)$, записывая последовательно  ее старший бит.

\newpage 
\subsubsection{Задача 3} Найти максимальную клику в маске. 

\textsc{\textbf{Решение:}}

\begin{enumerate}
  \item Если clique(mask) == true, то subclique(mask) = |mask|
  \item Возьмем максимальное значение из:\begin{enumerate}
    \item subclique(mask | v) - не берем v
    \item 1 + subclique(mask \& neighbour(v)) - берем v
  \end{enumerate}
\end{enumerate}

Такое тоже работает за $O(2^k)$
 
Теперь мы готовы решить основную задачу\dots

\begin{enumerate}
  \item [\textbf{Шаг 1}] Разобьем граф на 2 половинки, где будем искать клики. Пусть $corr[mask]$ - множество вершин правой доли, которые соединены со всеми вершинами mask.
  \item [\textbf{Шаг 2}] Хотим добавить их к mask, чтобы получилась клика. Единственное требование - все выбранные вершины $corr[mask]$ должны быть кликой --> \textsc{А это ведь Задача 3!!!}

То есть ответ будет состоять из $max (|mask| + subclique(mask))$, где mask - клика из левой части. Осталось понять, как считать $corr[mask]$
\item[\textbf{Шаг 0}] $corr[mask] = corr[mask | v] \ \& \ neighbour(v)$
\end{enumerate}

\subsection{ДП по профилю}

\subsubsection{Задача 1}

Пусть есть доска $n \times m$, сколько существует способов покрыть ее доминошками.

$dp[j][mask]$ - количество способов полностью покрыть $j$ столбцов, т. ч. mask - множество строк, где лежат "торчащие" доминошки.

\textit{"Торчащие" доминошки} - те, что расположены в $j$ и $j + 1$ столбцах.

\begin{enumerate}
  \item База: $dp[0][0] = 1, dp[0][\ne 0] = 0$
  \item Переход:
  Обозначим за $old_mask$ маску на $j-1$ столбце. Переберем по всевозможным old\_mask.
  \item Заметим, что, зафиксировав mask и old\_mask, картинка полностью заполняется.
Добавляем $dp[i - 1][old]$ к $dp[j][mask]$, если 
    \begin{enumerate}
  \item old $\cap$ mask = 0
  \item В old $\cup$ mask все блоки из нулей-четной длины
  \end{enumerate}
\end{enumerate}

Получаем асимптотику $O(4^n m)$, но можно подправить на $O(3^n m)$, если не рассматривать случаи $old \cap mask = 1$ в каком-то бите.

\subsection{Изломанный профиль}

Считаем, что профиль - теперь часть доски, покрытая доминошками по предположению. 

\textit{\underline{Комментарий:} Раньше профиль получался из целых столбцов, а теперь нет}


