% !TEX root = ../../../main.tex

\section{Продолжаем графы}

\subsection{2-КНФ}

\textit{Дана 2-КНФ. Есть ли у нее решение?}

\text{}

Кто не помнит, что такое 2-КНФ, вот \underline{пример:} $(x_1 \vee x_2) \wedge (\neg x_1 \vee x_3)\wedge (\neg x_1 \vee \neg x_4) = 1$


Понятно, что решение найдется только в случае равенства всех скобок.

$$a \vee b = (\neg a \to b) = (\neg b \to a)$$

Перепишем все дизъюнкции через импликации по правилу выше 

\begin{enumerate}
  \item Введем граф: в нем $2n$ вершин (для каждой переменной будет она и ее отрицание) и $2m$ ребер, соответствующие импликациям. 
  
\end{enumerate}

$$\xymatrix{
  *+[o]+[F]{\neg a} \ar[r] & *+[o]+[F]{b}\\
  *+[o]+[F]{\neg b} \ar[r] & *+[o]+[F]{a}
}$$

\begin{proposition}
  Формула выполнима $\Longleftrightarrow \forall p$ вершины $p$ и $\neg p$ лежат в разных КСС
\end{proposition}

\begin{proof}
  Пусть $\phi$ выполнима, но $p$ и $\neg p$ лежат в одной КСС. Переходя по стрелкам, мы однозначно определяем, что $p$ = $\neg p$ = 1

  В обратную сторону докажем, запустив алгоритм Косарайю: 

  \begin{enumerate}
    \item Положим $p = 1$, если $id[p] > id[\neg p]$, и $p = 1$, если $id[\neg p] > id[p]$
  \end{enumerate}

  Докажем, что это - выполняющий набор. Пойдем от противного. Есть скобка $(x \vee y) = 0 $
  $$(x \vee y) = 0\Rightarrow x = y = 0 \Rightarrow id[\neg x] > id[x], id[\neg y] > id[y]$$

  Как мы знаем по прошлой лекции, из наличия ребра $u \to v \Rightarrow$ $id[u] \le id[v]$. Получаем:

  $$id[\neg x] > id[x] \ge id[\neg y] > id[y] \ge id[\neg x] $$
\end{proof}


\subsection{Эйлеровость}
\begin{definition}
  Эйлеровым циклом в графе называется цикл, проходящий по всем ребрам ровно по 1 разу. 
\end{definition}

\begin{theorem}
  В ориентированном графе $G$ существует эйлеровый цикл тогда и только тогда, когда после удаления всех изолированных вершин $G$ становится сильно связным и $\forall v \ indeg(v) = outdeg(v)$ 
\end{theorem}

\begin{proof}
  \begin{enumerate}
    \item[$\Rightarrow$] Удалили все все изолированных вершины, получили граф, где есть цикл по всем ребрам. Тогда понятно, что количество вхождений в вершину равно количеству выходов из нее
    \item[$\Leftarrow$] Алгоритм. Пусть стек S - последовательность ребер на эйлеровом цикле. 
    \text{}
    
    Напишем \textbf{Псевдокод:}

    \begin{verbatim}
      def euler(v, pe):
        while из v есть неиспользованные исходящие ребра:
          пусть e - произвольное из них
          e - помечаем использованным
          e = (v, to); ++ptr[v]
          euler(to, e)
        S push(pe)
    \end{verbatim}
  \end{enumerate}
  \textit{Дальше идет индукция по размеру стека, ограничимся рисунком происходящего}
  $$\xymatrix{
  & & & \\
  {\circ}\ar[r]^>>>>>>{pe} ^>{V} & *=0{\bullet}\ar[ur] \ar[r] \ar[dr]^>>>>>>>{e} ^>{to} &\\
  & & &\\
  }$$
 
\end{proof}

\textbf{Как восстанавливать этот путь?}

\begin{lemma}
  Пусть граф $G$ удовлетворяет условию на равенство количества входящих и исходящих ребер, тогда $euler(v, pe)$ первым положит ребро на стек, когда будет в вершине $v$. 
\end{lemma}

\begin{proof}
  Понятно из картинки. Мы кладем ребро, когда возвращаемся в $v$.
\end{proof}

\begin{note}
Как проверить наличие эйлерова пути? Найти 2 вершины, являющиеся началом и концом потенциального пути, провести ребро и запустить алгоритм.

\textit{У конечных вершин indeg и outdeg отличаются на 1, причем в разные стороны}
\end{note}

\begin{proposition}
  Переложить описанный результат на неориентированный граф. 
\end{proposition}

\subsection{DFS на Неориентированных графах}

Назовем дерево ребер графа, вдоль которых ходит алгоритм $dfs$, деревом $dfs$. 

\begin{note}
  Ребра в неориентированном графе могут быть 2 типов:
  \begin{enumerate}
    \item Прямые или древесные - ребра, по которым мы переходим в вершину в алгоритме
    \item Обратные (остальные)
  \end{enumerate}
\end{note}

\begin{definition}
  $G$ - Неориентированный граф, $e$ - ребро в нем. Ребро $e$ называется мостом в нем, если при удалении $e$ в нем количество компонент связности возрастет. 
\end{definition}

\begin{definition}
  $V$ - точка сочленения, если при удалении $V$ количество компонент связности возрастет.
\end{definition}

\begin{proposition}
  Обратные ребра не являются мостами
\end{proposition}

Пусть в dfs поддерживает tin. Обозначим $ret[v] = min(tin[v], tin[u])$, где последнее выбирается из тех вершин $u$ в поддереве $v$, для которых существует обратное ребро $w \to u, \ w \in \text{поддереву $v$}$

\begin{proposition}
  $ret[v]$ - минимум из следующих значений:

  \begin{enumerate}
    \item $tin[v]$
    \item $tin[p]$ по всем обратным ребром $(v, p)$
    \item $ret[to]$ по всем прямым ребрам $(v, to)$
  \end{enumerate}
\end{proposition}

\begin{proposition}
  Ребро $(u, v)$ является мостом $\Leftrightarrow$ $(u, v)$ - древесное и $ret[v] = tin[v]$
\end{proposition}