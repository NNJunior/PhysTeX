% !TEX root = ../../../main.tex

\section{Минимальные остовные деревья}
\begin{definition}
  Пусть $G = (V, E)$ - неориентированный граф. Тогда остовным подграфом $G$ называется такой граф $H = (V', E')$, что $V' = V, E' \subset E$.
\end{definition}
\begin{definition}
  Остовным деревом графа $G$ (MST) называется любой его подграф, являющийся деревом.
\end{definition}

\begin{lemma}{(о безопасном ребре)}
  Пусть $S$ - множество ребер, такие что $\exists$ MST T, содержащее все ребра $S$. Пусть $C$ - одна из компонент связности относительно $S$ $(V, S)$, $e$ - самое дешевое ребро между $C$ и $V \setminus C $. Тогда $S + e$ - тоже подмножество некоторого MST.
\end{lemma}

\begin{proof}
  $S + e \subset T$
  \begin{enumerate}
    \item[а)] Если да, то доказывать нечего
    \item[б)] Если нет, то рассмотрим путь между $u$ и $v$ в дереве $T$. Пусть $e'$ - ребро в нем, выходящее из C.
    $$\omega(e) \le \omega(e')$$

    Заметим, что если удалить ребро $e'$ и добавить e, то получим остовное дерево с лучшим ребром. Противоречие
    
    
    $$\xymatrix{
    & & *={}\ar@{-}_{T}[r]&*={}\ar@{-}^{e'}[dr]&\\
    &*={}\ar@{-}[ru]&&&*={}\ar@{-}[dl]\\
    & &*={}\ar@{-}[lu] &*={}\ar@{.}^{e}[l] & & &}$$
  \end{enumerate}
\end{proof}

\subsection{Алгоритм Прима}

\begin{enumerate}
  \item Заводим текущее остовное дерево $S = \varnothing$
  \item $S_1 = \{e_1\}$
  \item $S_2 = \{e_2\} \vee S_1$
  \item Пусть $S_i$ - текущее множество ребер. На каждом шаге будем рассматривать самое дешевок ребро между $C_i$ и $V \setminus C_i$ и добавлять его, как в примерах выше.
  $$S_{i + 1} = S_i + e_{i + 1}, C_{i + 1} = C_i + V_{i + 1}$$
\end{enumerate}

\textsc{Асимптотика: $O(n^2 + m) \sim O(n^2)$}

Пусть $d[v]$ - наименьшая стоимость ребра между $C_i$ и $v$. На каждом шаге в $C_i$ добавляется вершины $v$ с минимальным значением $d[v]$. После выбора $v$:
\begin{verbatim}
  for (u: g[v]) {
    d[u] = min(d[u], cost(v, u));
  }
\end{verbatim}

\begin{note}
Как и в алгоритме Дейкстры, если завести структуру, способную извлекать минимальное значение и делать decreaseKey, то можно обойтись асимптотикой $O(m + n\log{n})$ с кучей Фибоначчи и $O(m \log{n})$ с биномиальной кучей.
\end{note}
\subsection{Алгоритм Крускала}
\begin{enumerate}
  \item Сортируем все ребра в порядке возрастания веса. 
  \item Идем по $m$ ребрам в этом порядке, каждое ребро добавляем в ответ, если оно не образует цикла с другими.
  
  \noindent
  \textit{Корректность следует из лемма о безопасном ребре}

  \textbf{Как проверить наличие цикла?}
\end{enumerate}

\subsubsection{Система непересекающихся множеств (СНМ)}
\begin{enumerate}
  \item[$\then$] \textbf{unite:} объединение двух непересекающихся множеств.
  \item[$\then$] \textbf{same?} : проверить лежат ли два заданных элемента в одном множестве. 
\end{enumerate}

Через такую структуру достаточно хранить компоненты связности в качестве рассматриваемых множеств и добавлять ребро, только если оно соединяет вершины разных множеств.

Каждое множество в СНМ храним в виде корневого дерева (дерева с отмеченной вершиной - корнем). Тогда для каждой вершины достаточно дойти до корня дерева и сравнить эти вершины. 

\begin{verbatim}
  int get(v) {
    if (p[v] == v) {
      return v;
    }

    return get(p(v));
  }
\end{verbatim}

Чтобы провести $unite$ достаточно подвесить корень одного дерева к корню другого.

\textbf{Важный нюанс:} Подвешиваем всегда меньшее по размеру дерево к большему. 

Пусть $s[r]$ - размер поддерева вершины $r$
\begin{verbatim}
  unite(u, v) {
    u = get(u) \\ корень 1 дерева
    v = get(v) \\ корень 2 дерева
    if (s[u] < s[v]) swap(u, v)
    p[v] = u \\ подвешиваем дерево с меньшим размером
    s[u] += s[v]
  }
\end{verbatim}

Будем дополнительно использовать эвристику сжатия путей:

Если мы впервые обращаемся к вершине (что означает, что вершина пока не подвешена напрямую к корню), то все промежуточные до корня вершины мы будем обновлять корректно и подвешивать к корню. 

\begin{theorem}{(б/д)}
  Пусть функция Акермана $A(m, n):$
  \begin{equation}
    A(m, n) =: 
    \begin{cases}
      n + 1 & \text{если $m = 0$}\\
      A(m - 1, 1) & \text{если m > 0, n = 0}\\
      A(m - 1, A(m, n - 1)) & \text{если n, m > 0}
    \end{cases}
  \end{equation}

   Определим $\alpha(k) = min \{n: A(n, n) \ge k \}$ Тогда асимптотика обработки запроса есть $O^*(\alpha(m))$
\end{theorem}
\begin{note}
  $A(4, 4) = 2^{2^{2^{65536}}} - 3$. Так что $\alpha(n)$ - довольно маленькое число.
\end{note}

\noindent
Возвращаясь к алгоритму Крускала, получаем асимптотику $O(SORT + m \cdot \alpha(n))$

\subsection{Алгоритм Борувки}
\begin{enumerate}
  \item Для каждой вершины определить самое дешевое исходящее ребро.
  \item Все выбранные ребра добавить в ответ; сжать компоненты связности и запустить рекурсию. 
\end{enumerate}

\begin{note}
  Если из вершины выходит несколько ребер минимального веса, то мы будем брать то из них, которое имеет минимальный номер.
\end{note}

\textbf{Почему не появляется циклов?}

Ориентируем выбранные ребра "от себя". Получим функциональный граф. Понятно, что для каждой вершины будет выбрано ровно 1 исходящее ребро (на этапе рассмотрения этой вершины).

\begin{enumerate}
  \item Петель не бывает.
\begin{proof}
  Очев.
\end{proof}
  \item Цикл длины больше 2 возникнуть не может. 
  \begin{proof}
    Несложно понять, что пройдя по этому циклу, мы получим, что ребра на нем не возрастают. Но если рассмотреть первую рассмотренную вершину из этого цикла, то мы получим, что все веса должны быть равны. В этом случае произойдет убывание номеров ребер у вершин:
    $$number(1) < number(2) < number(3) < \dots < number(n) < number(1)$$ 
  \end{proof}
  \item Цикл длины 2 возникает только при ориентировании одного ребра в 2 стороны
  \begin{proof}
    Можно считать, что всегда между 2 вершинами существует не больше 2 ребер (ведь среди кратных можно оставить наименьшее). А тогда цикл на 2 вершинах возможен только при описанном ориентировании.
  \end{proof}
\end{enumerate}

\textbf{Корректность?}

Мы получаем некоторое остовное дерево. Почему же оно является минимальным?

Ответ - в многократном применении леммы о безопасном ребре. 

\textbf{Асимптотика:} $O(m \log{n})$

\begin{proposition}
  Глубина рекурсии всегда не превосходит $\log{n}$
\end{proposition}
\begin{proof}
  В худшем случае количество вершин уменьшается вдвое, так как каждая компонента будет содержать хотя бы 2 вершины. Алгоритм остановится, когда вершина будет 1.
\end{proof}